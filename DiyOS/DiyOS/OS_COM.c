/**
********************************************************************************
* @file    OS_COM.c
* @author  Sai
* @version 01V01
* @date    2020-03-08
* @brief  系统公共功能源代码
* @note    
* @attention
********************************************************************************
*/

/*位图快速查找表*/
unsigned char bitmaptable[] = 
{
/*0x00*/ 0xff, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x10*/ 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x20*/ 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x30*/ 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x40*/ 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x50*/ 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x60*/ 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x70*/ 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x80*/ 0x07, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0x90*/ 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0xA0*/ 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0xB0*/ 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0xC0*/ 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0xD0*/ 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0xE0*/ 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
/*0xF0*/ 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00
};


#include "OS_COM.h"

/**
 * @brief 位图初始化
 * @param[in] pbitmap 位图数据指针
 * @note 将位图数据清零
 * @retval 无
 */
void OS_COM_InitBitmap(p_tBitmap_t pbitmap)
{
	pbitmap->unBitmap = 0;
}

/**
 * @brief 设置位图
 * @param[in] pbitmap 位图数据指针 pos 设置的位图位置
 * @note 将pos与位图进行或运算
 * @retval 无
 */
void OS_COM_SetBitmap(p_tBitmap_t pbitmap,unsigned int pos)
{
	 pbitmap->unBitmap = pbitmap->unBitmap | (1 << pos);
}

/**
 * @brief 清除位图
 * @param[in] pbitmap 位图数据指针 pos 待清除的位图位置
 * @note 无
 * @retval 无
 */
void OS_COM_ClrBitmap(p_tBitmap_t pbitmap,unsigned int pos)
{
	pbitmap->unBitmap = pbitmap->unBitmap & (~(1 << pos));
}

/**
 * @brief 获取第一个位置
 * @param[in] pbitmap 位图数据指针
 * @note 从位图查找表中查找第一个置一的位置，默认0为最高31为最低
 * @retval 无
 */
unsigned int OS_COM_GetFirstBit(p_tBitmap_t pbitmap)
{
	  unsigned int unPos = 0xff;
		if(pbitmap->unBitmap & 0xff)
		{
				unPos = bitmaptable[pbitmap->unBitmap & 0xff];
		}
		else if(pbitmap->unBitmap & 0xff00)
		{
			  unPos = bitmaptable[(pbitmap->unBitmap >> 8) & 0xff] + 8;
		}
		else if(pbitmap->unBitmap & 0xff0000)
		{
			  unPos = bitmaptable[(pbitmap->unBitmap >> 16) & 0xff] + 16;
		}
		else 
		{
			  unPos = bitmaptable[(pbitmap->unBitmap >> 24) & 0xff] + 24;
		}
		
		return unPos;
}

/**
 * @brief 双向链表节点初始化
 * @param[in] phead 头节点
 * @note 将双向链表计数清零，前驱节点和后驱节点都指向头节点
 * @retval 返回0表示初始化成功，返回非0表示初始化失败
 */
int OS_COM_InitList(p_nodelist_t phead)
{
	  if(NULL == phead)
		{
				return -1;
		}			
	
		phead->head.pre = &phead->head;
	  phead->head.next = &phead->head;
	
	  phead->unNodeCnt = 0;
	
		return 0;
}

/**
 * @brief 双向链表节点的头部添加
 * @param[in] phead 头节点，pnode 待添加的节点
 * @note 尾部插入节点
 * @retval 返回0表示插入成功，返回非0表示插入失败
 */
int OS_COM_AddNode(p_nodelist_t phead,p_node_t pnode)
{
		if(NULL == phead || NULL == pnode)
		{
				return -1;
	  }
		
		pnode->next = &phead->head;
		pnode->pre = phead->head.pre->next;		
		phead->head.pre->next = pnode;
		phead->head.pre = pnode;
		
		phead->unNodeCnt++;
		
		return 0;
}

/**
 * @brief 双向链表节点的删除
 * @param[in] phead 头节点，pnode 待删除的节点
 * @note 无
 * @retval 返回0表示删除成功，返回非0表示删除失败
 */
int OS_COM_DelNode(p_nodelist_t phead,p_node_t pnode)
{
		if(NULL == phead || NULL == pnode)
		{
				return -1;
		}		
		
	  if(phead->unNodeCnt > 0)
		{
				pnode->pre->next = pnode->next;
				pnode->next->pre = pnode->pre;
				
				pnode->pre = pnode;
				pnode->next = pnode;
			
			  phead->unNodeCnt--;	
		}
				
		return 0;
}

/**
 * @brief 移除双向链表节点的第一个节点
 * @param[in] phead 头节点
 * @note 无
 * @retval 返回删除后的第一个节点
 */
p_node_t OS_COM_RemoveFirstNode(p_nodelist_t phead)
{
		if(NULL == phead || phead->unNodeCnt <= 0)
		{
				return NULL;
		}		
		
		p_node_t nextnode = phead->head.next;
		phead->head.next = nextnode->next;
		nextnode->next->pre = &phead->head;
		
		nextnode->next = nextnode;
		nextnode->pre = nextnode;
		
		phead->unNodeCnt--;	
		
		return nextnode;
}


/**
 * @brief 获取双向链表中个数
 * @param[in] phead 链表指针
 * @note 无
 * @retval 返回链表节点个数 
 */
unsigned int OS_COM_GetNodeCount(p_nodelist_t phead)
{
		return phead->unNodeCnt;
}	
